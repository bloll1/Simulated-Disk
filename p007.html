<h1 id="acknowledgment">Acknowledgment</h1>
<p>The VSSD++ and VSFS++ assignments were inspired by Rice University's various Valnix disk and file system assignments that can be found on the Web. They also draw from the peripheral and file system descriptions in OSTEP.</p>
<h1 id="overview">Overview</h1>
<p>Students will implement Very Simple Simulated Disks, vssd, to gain some facility with the abstract interface of a disk and, by implementing two different kinds of disks, how that abstract interface smooths over differences in the underlying "hardware". This is exactly the purpose of driver code in an operating system: uniform presentation of heterogeneous hardware to the next higher layer of abstraction.</p>
<p>The vssd are block-based storage, effectively persistent arrays of blocks. Note that "sector" and "block" are synonymous in this and following assignment. Block contents are <em>opaque</em> to the vssd; the vssd treats them as uninterpreted sequences of bytes (with one exception described below).</p>
<p>One of the major challenges of operating system design is the problem of dealing with different types of hardware devices while providing a convenient programming interface for controlling them. In this assignment, students explore this problem by looking at supporting "physical" and "RAM" disks.</p>
<h1 id="the-abstract-programming-interface-api">The Abstract Programming Interface (API)</h1>
<ol>
<li><p>The Public Interface</p>
<p>An API is the publicly exposed interface of a library or subsystem.</p>
<ol>
<li><p>Consider <code>List</code> in Java.</p>
<p>The client code, that <em>using</em> the <code>List</code> interface, need not know anything about the internal representation of a <code>LinkedList</code> or an <code>ArrayList</code>. The <code>List</code> provides a common interface for the client and the implementation can change according to need without client code needing rewriting.</p></li>
<li><p>API controls complexity through abstraction.</p>
<p>As the name indicates, the <strong>Abstract</strong> Programming Interface uses abstraction to separate the programmer's task into two layers: one is <em>implementing</em> the API atop a particular implementation; the other is <em>using</em> an instance of the API. So long as the contract is well understood, a programmer can focus on one side with little intellectual overhead devoted to the other side of the divide.</p></li>
</ol></li>
<li><p>The <strong>Facade Pattern</strong></p>
<p>An API is often an example of the facade <strong>design pattern</strong>.</p>
<ol>
<li><p>Design Pattern?</p>
<p>A <strong><a href="https://www.tutorialspoint.com/design_pattern/design_pattern_overview.htm">design pattern</a></strong> is a named relationship between one or more classes in an object-oriented program. The naming comes after a programmer sees the same relationship recurring in multiple programs. Taken together, design patterns form a "pattern language" for talking about entities and their <em>relationships</em> within a program at a level of abstraction above that provided by any given programming language.</p>
<p>The <strong><a href="https://www.tutorialspoint.com/design_pattern/facade_pattern.htm">facade pattern</a></strong> (analogous to a building's facade) is a pattern where an object provides a fixed interface to smooth over differences in multiple underlying subsystems. The facade is the interface and a particular backend can be used through the facade after a driver/translator is implemented and wrapped around the subsystem, hiding the specific complexities. One hard part of designing a facade is extracting the minimal functionality that defines <strong>all</strong> of the subsystems that will be brought into it.</p></li>
<li><p>vssd++</p>
<p>vssd++ (the C++ evolution of the vssd assignment) uses a simple abstract base class to provide the facade over two different types of disk drives. One test harness, written to the API, can test multiple implementations of a simulated disk.</p></li>
</ol></li>
</ol>
<h1 id="vssd-the-interface">vssd++: The Interface</h1>
<p>As you are hopefully aware, disk drives come a wide variety of flavorsâ€”hard disks, floppy disks, zip disks, CD-ROMS, DVDs, and solid-state drives. At the lowest level, all disk drives are "block devices." That is, the devices only know how to operate on blocks of data that are typically between 512 and 4096 bytes in size. Disks really only have two primary functions:</p>
<pre><code>VVSSD::read(unsigned int blocknum, void *buffer)
VVSSD::write(unsigned int blocknum, void *buffer)
</code></pre>
<p>Each member function is called on the disk that it is to operate on. Each takes a physical block number on which to operate and a pointer into memory for a block's worth of data; if the disk is not obvious, consider what <code>this</code> represents. <code>read</code> retrieves the designated block of data from the disk and copies it into the buffer. <code>write</code> takes the data that's stored in the buffer and copies it in the designated disk sector.</p>
<p>Although disks are easy to describe <em>at a high-level</em>, supporting them <em>in detail</em> is tricky. As mentioned, a wide variety of disk devices could be attached to a system. Moreover, there are a lot of other things that behave somewhat like disks, but which aren't (disk images, RAM disks, network storage devices, etc.). Implementing an established API is an exercise in papering over these differences.</p>
<ol>
<li><p>The Interface</p>
<p>The interface for a vssd++ is represented in the abstract class <code>VVSSD</code> (Virtual Very Simple Simulated Disk). An <em>abstract class</em> is similar to the Java <code>interface</code> (or <code>abstract</code> keyword) in that it can provide a set of member function declarations that can be programmed against (the client code uses the interface) and <strong>must</strong> be implemented by classes extending the abstract class.</p>
<pre><code>class VVSSD {
 public:
  virtual std::size_t blockSize() const = 0;
  virtual std::size_t blockCount() const = 0;
  virtual DiskStatus status() const = 0;
  virtual DiskStatus read(blocknumber_t block, void * buffer) = 0;
  virtual DiskStatus write(blocknumber_t block, void * buffer) = 0;
  virtual DiskStatus sync() = 0;
};
</code></pre>
<ol>
<li><p>C++ Translations</p>
<ol>
<li><p><code>DiskStatus</code> is an enumerated type for specifying the outcome of disk operations. It includes values such as <code>OK</code>, <code>NOT_READY</code>, and <code>NOT_YET_IMPLEMENTED</code>.</p></li>
<li><p><code>virtual</code> methods are like all Java member functions: the lowest definition of the function for the <strong>actual</strong> type is called, regardless of the <strong>apparent</strong> type. Assume <code>FileVSSD</code> extends <code>VVSSD</code>, defining all the interface methods. Then</p>
<pre><code>VVSSD * disk = new FileVSSD(...the parameters that work...);
disk-&gt;sync();
</code></pre>
<p>calls <code>FileVSSD::sync</code>, not the non-existent <code>VVSSD::sync</code>.</p>
<ol>
<li><p>(You can assume that leaving <code>virtual</code> off the declaration does something different. It causes the call to be resolved based on the <strong>apparent</strong> rather than the actual type. See you in <em>Programming Languages</em> for a discussion of how that might work.)</p></li>
</ol></li>
<li><p><code>const</code> after the parameter list of a member function indicates that the member function is safe to call on a <code>const</code> object of the class. Colloquially it mean the function does not change any fields of the object (as with much of C++, it is more omplicated than that blanket statement but we do not care).</p></li>
<li><p>And the final = = 0; = at the end of the line. That says there is no function definition for the declared function. That is, if a declaration of a function ending with just the semicolon is a promise to the compiler that there <em>is</em> a definition somewhere and it can be found at link time and extending classes will inherit it if they do not supply their own, the equals zero can be read as requiring extending classes provide their own definition.</p></li>
</ol></li>
<li><p>Semantics</p>
<ol>
<li><p>The first three functions are informational: they return the <em>geometry</em> of the disk in terms of the number and size (in bytes) of the disk and the status of the last call to an API function. These three functions are <code>const</code> because they only read data from the disk and return it to the caller.</p></li>
<li><p>The <code>read</code> and <code>write</code> methods are the core of the interface: they read a block from and write a block to the underlying disk. They return a <code>DiskStatus</code> value to let the caller know whether or not it worked.</p></li>
<li><p><code>sync</code> flushes any buffered writes out to the disk. It is most likely just a NOP since this assignment says nothing about buffering of data.</p></li>
</ol></li>
</ol></li>
</ol>
<h1 id="the-disk-drives">The Disk Drives</h1>
<p>This project requires you to implement two different disk drives, one purely in memory (and therefore not actually persistent across multiple connections) and the other inside a disk file. The test code, programmed against the <code>VVSSD</code> interface, is agnostic as to what kind of disk is in use at any given moment. Only when connecting to a disk to use it does it matter as the correct constructor must be called.</p>
<ol>
<li><p>The Constructors</p>
<p>To keep the new code from being overwhelming, the test framework has (commented out when you get it) calls to the constructors for the two types of disks you are implementing. Each takes four parameters:</p>
<ul>
<li><code>block_size</code> the size in bytes of the disk; must be greater than or equal to 32</li>
<li><code>block_count</code> the number of blocks on the disk; must be greater than or equal to 2</li>
<li><code>filename</code> the name of the file; can be empty for disks that do not use one</li>
<li><code>truncate</code> a Boolean indicating whether the disk representation should be reinitialized for those disks where this is a choice; defaults to false</li>
</ul>
<p>To use the given constructor, just by uncommenting it, include all four parameters in the disk's constructor. Alternatively, remove the parameters that the disk does not need when uncommenting. C++ supports several ways to build factory methods that are more automatic than the hand-build one used in the test code. The automation comes at the price of using very sophisticated language constructs, a price beginning C++ programmers should not have to pay.</p></li>
<li><p>Sector Zero</p>
<p>Block 0 is special: it is an error to read or write to it through the read or write methods in the interface. That block is free for the disk itself to use. Suggested uses: the first two unsigned int sized blocks should store the geometry of the disk so that when reopening a persistent disk, you can check that the geometry matches that given. You could even imagine a constructor that did not need the geometry and could automatically open any disk properly. After the geometry there might be a signature, a sequence of bytes that lets the opening program verify that the file being opened was written by a compatible version same program.</p>
<p>Note that Sector Zero is the reason for the geometry limitations in the previous section: 32 bytes so two integers and a signature can fit; at least 2 sectors so at least 1 is available to the user.</p></li>
<li><p>RAMVSSD</p>
<p>The RAM disk, <code>RAMVSSD</code> creates a memory buffer the size of the disk drive it is created with. Since the data is in memory, when the disk is disconnected, the data goes away. The RAM disk is non-persistent.</p>
<p>Note that you <strong>must</strong> either call <code>delete[]</code> to release a raw pointer or make use of the new <code>unique_ptr&lt;&gt;</code> template that can call it for you. Using a raw pointer is lower level and perfectly acceptable in this class; the other approach is an attempt to make C++ memory management easier.</p></li>
<li><p>FileVSSD</p>
<p>A file disk, <code>FileVSSD</code>, also known as a <em>disk image</em>, is a file that is treated (by your disk drive class) as a block-addressable data store. The file underlying the <code>FileVSSD</code> <strong>is</strong> persistent. This means that the disk can be disconnected (or a program using it can terminate) and the data in the various sectors will remain where it was the next time it is connected.</p>
<p>Further, this means there are actually two different operations when constructing a <code>FileVSSD</code>: open and initialize it so all user-addressable blocks are filled with zero bytes or open an already existing disk image. When opening an existing image, use the contents of Sector Zero to confirm the geometry and authenticity of the image.</p></li>
</ol>
<h1 id="getting-started">Getting Started</h1>
<ol>
<li><p>In the class code repository there is a new directory, <code>pVSSD</code>. It has the same multi-module structure of our programs. Copy it into a directory with a clean git database and <code>make</code> it. It will give lots of errors when you test the included device but it will compile.</p>
<ol>
<li><p>Your new files should go in <code>src/vssd-solution</code>, along side the <code>UnImplVSSD</code> files.</p></li>
</ol></li>
</ol>
<h1 id="challenges---what-you-can-and-cannot-do">Challenges - What you <strong>can</strong> and <em><strong>cannot</strong></em> do</h1>
<p>You are implementing the <code>RAMVSSD</code> and <code>FileVSSD</code> devices.</p>
<ol>
<li><p>Put the device files (<code>.h=/</code>.cpp=) in the <code>src/vssd-solution</code> folder.</p></li>
<li><p>Each of your device classes <strong>must</strong> inherit from (Java: <code>extend</code>) <code>VVSSD</code>. That means the name of the class must be followed by a colon and the name of the parent class.</p></li>
<li><p>When you are done, there will be 4 devices in the program:</p>
<ul>
<li><code>VVSSD</code> the interface device; cannot be instantiated
<ul>
<li><code>UnImplVSSD</code> a dummy device that lets the code you get compile; all methods return <code>NOT_YET_IMPLEMENTED</code>.</li>
<li><code>RAMVSSD</code> the RAM disk device</li>
<li><code>FileVSSD</code> the disk image device</li>
</ul></li>
</ul></li>
<li><p>If any file includes the <code>.h</code> file for a device, that file <em>refers</em> to the given device.</p>
<ol>
<li><p>No device extending <code>VVSSD</code> can refer to any device other than its parent device.</p></li>
</ol></li>
<li><p>You may modify <code>main/main.cpp</code> in order to permit instantiation of the new devices.</p></li>
<li><p>You may modify <code>vssd/DiskStatus.*</code> if you find more errors useful. Make sure to add the new errors to the two translation functions in the <code>.cpp</code> file.</p></li>
<li><p><code>vssd/VVSSD.h</code> <strong>MUST NOT</strong> change.</p></li>
</ol>
<h1 id="adviseapproach">Advise/Approach</h1>
<ol>
<li><p>The <em>implementation</em> of a device is exactly the implementation of a class extending our interface class.</p>
<ol>
<li><p>After implementation, the device must be uncommented in <code>main.cpp</code>.</p></li>
</ol></li>
<li><p>The <code>RAMVSSD</code> and <code>FileVSSD</code> classes will be almost identical in their declaration with the same abstract methods overridden and very similar constructors. The definition of the methods will differ.</p></li>
<li><p>The C++ used</p>
<ol>
<li><p><code>RAMVSSD</code> needs mainly <code>new</code>, <code>delete[]</code> and <code>std::memcpy</code>.</p></li>
<li><p><code>FileVSSD</code> uses the <code>fstream</code> interface with <code>seekg/p</code>, <code>read</code>, <code>write</code>, and opening and closing.</p></li>
</ol></li>
</ol>
<h1 id="deliverablessubmission-method">Deliverables/Submission Method</h1>
<ol>
<li><p>Submission is through <code>git</code></p></li>
<li><p>The project is to be developed in a project directory structured as in the <code>cppProjectTemplate</code></p>
<ol>
<li><p>Name the directories under <code>src/</code> according to your choice of names for modules in the project</p></li>
<li><p>Make sure there is one executables module using the <code>executables.mk</code> Makefil file</p></li>
<li><p>Copy (recursively) the <code>src/module/</code> directory to start new modules as necessary</p>
<ol>
<li><p>You need to make sure the names of all modules are in <code>src/allModule.</code></p></li>
<li><p>The recursive copy gets the module version of <code>module.mk</code> into the directory</p></li>
</ol></li>
</ol></li>
<li><p>The base directory of the project is to be a <code>git</code> repository</p>
<ol>
<li><p>Make sure it has an appropriate C++ (and your editor) <code>.gitignore</code> file.</p></li>
<li><p>Make sure to <strong>delete</strong> the <code>.git</code> folder (the whole history of the template) <strong>and</strong> run <code>git init</code> to create a new history</p></li>
</ol></li>
<li><p>Log in to <code>GitTea</code> at <a href="https://cs-devel.potsdam.edu">https://cs-devel.potsdam.edu</a></p>
<ol>
<li><p>Create a new, empty repository on <code>cs-devel</code>.</p>
<ol>
<li><p>The name <strong>must</strong> begin with <code>p001</code>.</p></li>
<li><p>The name of the repository of <em>each</em> program you turn in will begin with <code>p###</code> where "###" is the number of the assignment.</p></li>
</ol></li>
<li><p>After the <code>GitTea</code> will guide you to connect your <em>local</em> repository (where your solution lives) to the <em>remote</em> repository.</p>
<ol>
<li><p>Notice that the instructions differ on when you create the new repository on <code>cs-devel</code>.</p></li>
</ol></li>
</ol></li>
<li><p>Submit using git to push to git@cs-devel.potsdam.edu in the repo you made.</p></li>
</ol>
